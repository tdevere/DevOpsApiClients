"""
PowerShell implementation template for Azure DevOps API operations.

Generated scripts source _shared/AdoAuth.ps1 and _shared/AdoHttp.ps1
for consistent auth, URL building, and error handling.
"""

from _generator.operation_def import OperationDef, ParamDef


def render_powershell(op: OperationDef) -> str:
    """Render a PowerShell implementation script from an OperationDef."""
    lines = []

    # Header comment block
    lines.append('# AUTO-GENERATED by _generator — do not edit by hand.')
    lines.append('# Source of truth: _generator/definitions/')
    lines.append('<#')
    lines.append('.SYNOPSIS')
    lines.append(f'    {op.synopsis}')
    lines.append('')
    lines.append('.DESCRIPTION')
    lines.append(f'    Calls  {op.http_method} {{org}}/{op.url_path}?api-version={op.api_version}')
    lines.append(f'    Uses Basic Auth with a PAT stored in $env:AZURE_DEVOPS_PAT.')
    lines.append('')
    lines.append('.LINK')
    lines.append(f'    {op.docs_url}')
    lines.append('#>')
    lines.append('')

    # Param block
    lines.append('[CmdletBinding()]')
    lines.append('param (')

    all_params = []

    # Track names already emitted to prevent duplicate parameters
    _emitted_names: set = set()

    # CLI params first (Mandatory) — skip if name collides with standard params
    # that will be added below (Organization, ProjectId, Pat)
    _standard_ps_names = {"Organization", "Pat"}
    if op.project_scoped:
        _standard_ps_names.add("ProjectId")

    for p in op.params:
        if p.cli_flag:
            ps_name = p.ps_name or _to_pascal(p.name)
            if ps_name in _standard_ps_names:
                continue  # Will be added as env-backed param below
            if ps_name in _emitted_names:
                continue
            _emitted_names.add(ps_name)
            all_params.append(
                f'    [Parameter(Mandatory)]\n    [string]${ps_name}'
            )

    # Standard env-backed params
    all_params.append(
        '    [Parameter()]\n    [string]$Organization = $env:AZURE_DEVOPS_ORG'
    )
    _emitted_names.add("Organization")
    if op.project_scoped:
        all_params.append(
            '    [Parameter()]\n    [string]$ProjectId = $env:PROJECT_ID'
        )
        _emitted_names.add("ProjectId")

    # Extra env params — skip those already handled above
    _already_handled = {"AZURE_DEVOPS_ORG", "AZURE_DEVOPS_PAT"}
    if op.project_scoped:
        _already_handled.add("PROJECT_ID")
    for p in op.params:
        if not p.cli_flag and p.env_var not in _already_handled:
            ps_name = p.ps_name or _to_pascal(p.name)
            if ps_name in _emitted_names:
                continue
            _emitted_names.add(ps_name)
            all_params.append(
                f'    [Parameter()]\n    [string]${ps_name} = $env:{p.env_var}'
            )

    all_params.append(
        '    [Parameter()]\n    [string]$Pat = $env:AZURE_DEVOPS_PAT'
    )
    _emitted_names.add("Pat")

    lines.append(',\n\n'.join(all_params))
    lines.append(')')
    lines.append('')

    lines.append("Set-StrictMode -Version Latest")
    lines.append("$ErrorActionPreference = 'Stop'")
    lines.append('')

    # Source shared helpers
    lines.append('#--- Shared helpers ---------------------------------------------------------')
    lines.append("$_sharedDir = Join-Path (Join-Path (Split-Path $PSScriptRoot -Parent) '..') '_shared'")
    lines.append(". (Join-Path $_sharedDir 'AdoAuth.ps1')")
    lines.append(". (Join-Path $_sharedDir 'AdoHttp.ps1')")
    lines.append('')

    # Validation using Assert-AdoEnv
    lines.append('#--- Validate inputs --------------------------------------------------------')
    lines.append("Assert-AdoEnv -Name 'Organisation' -Value $Organization")
    if op.project_scoped:
        lines.append("Assert-AdoEnv -Name 'ProjectId' -Value $ProjectId")
    _validated = {"AZURE_DEVOPS_ORG", "AZURE_DEVOPS_PAT"}
    if op.project_scoped:
        _validated.add("PROJECT_ID")
    for p in op.params:
        if p.required:
            ps_name = p.ps_name or _to_pascal(p.name)
            if p.env_var in _validated:
                continue
            lines.append(f"Assert-AdoEnv -Name '{ps_name}' -Value ${ps_name}")
    lines.append("Assert-AdoEnv -Name 'PAT' -Value $Pat")
    lines.append('')

    # API version
    lines.append('#--- API version ------------------------------------------------------------')
    lines.append(f"$ApiVersion = '{op.api_version}'")
    lines.append('')

    # Auth header using shared helper
    lines.append('#--- Build auth header ------------------------------------------------------')
    lines.append('$headers = New-AdoAuthHeader -Pat $Pat')
    lines.append('')

    # Request body
    if op.body_fields:
        lines.append('#--- Build request body -----------------------------------------------------')
        lines.append('$body = @{')
        nested = {}
        for bf in op.body_fields:
            val = _resolve_body_source_ps(bf, op)
            if '.' in bf.json_path:
                parts = bf.json_path.split('.', 1)
                parent = parts[0]
                child = parts[1]
                if parent not in nested:
                    nested[parent] = []
                nested[parent].append((child, val))
            else:
                lines.append(f'    {bf.json_path} = {val}')
        for parent, children in nested.items():
            lines.append(f'    {parent} = @{{')
            for child_name, child_val in children:
                lines.append(f'        {child_name} = {child_val}')
            lines.append(f'    }}')
        lines.append('} | ConvertTo-Json -Depth 3')
        lines.append('')

    # URL construction using New-AdoUrl
    lines.append('#--- Call the API -----------------------------------------------------------')
    url_path = op.url_path
    # Replace {param} with PowerShell variable references
    for p in op.params:
        placeholder = '{' + p.name + '}'
        if placeholder in url_path:
            ps_name = p.ps_name or _to_pascal(p.name)
            url_path = url_path.replace(placeholder, f'${ps_name}')

    if op.project_scoped and op.base_host != 'dev.azure.com':
        lines.append(f'$uri = New-AdoUrl -Organization $Organization -Path "{url_path}" -ApiVersion $ApiVersion -Project $ProjectId -BaseHost "{op.base_host}"')
    elif op.project_scoped:
        lines.append(f'$uri = New-AdoUrl -Organization $Organization -Path "{url_path}" -ApiVersion $ApiVersion -Project $ProjectId')
    elif op.base_host != 'dev.azure.com':
        lines.append(f'$uri = New-AdoUrl -Organization $Organization -Path "{url_path}" -ApiVersion $ApiVersion -BaseHost "{op.base_host}"')
    else:
        lines.append(f'$uri = New-AdoUrl -Organization $Organization -Path "{url_path}" -ApiVersion $ApiVersion')
    lines.append('')
    lines.append(f'Write-Verbose "{op.http_method} $uri"')
    lines.append('')

    # API call
    method = op.http_method.capitalize()
    if op.success_status == 204:
        # Use Invoke-WebRequest for 204 responses
        if op.body_fields:
            lines.append(f"$response = Invoke-AdoRestMethod -Uri $uri -Method {method} -Headers $headers -Body $body -ExpectedStatusCode {op.success_status}")
        else:
            lines.append(f"$response = Invoke-AdoRestMethod -Uri $uri -Method {method} -Headers $headers -ExpectedStatusCode {op.success_status}")
        lines.append('')
        lines.append('#--- Output -----------------------------------------------------------------')
        lines.append(f'if ($response.StatusCode -eq {op.success_status}) {{')
        if op.output_message:
            lines.append(f'    Write-Host "{op.output_message}"')
        else:
            lines.append(f'    Write-Host "Operation completed successfully."')
        lines.append('} else {')
        lines.append('    Write-Warning "Unexpected status code: $($response.StatusCode)"')
        lines.append('}')
    else:
        if op.body_fields:
            lines.append(f"$response = Invoke-RestMethod -Uri $uri -Method {method} -Headers $headers -Body $body -ContentType 'application/json'")
        else:
            lines.append(f"$response = Invoke-RestMethod -Uri $uri -Method {method} -Headers $headers -ContentType 'application/json'")
        lines.append('')

        # Version guard
        if op.version_guard_keys:
            lines.append('#--- Version guard ----------------------------------------------------------')
            for key in op.version_guard_keys:
                lines.append(f"if ($response.PSObject.Properties.Name -notcontains '{key}') {{")
                lines.append(f"    Write-Warning \"Unexpected response shape — missing '{key}'. The server may not support api-version $ApiVersion.\"")
                lines.append('}')
            lines.append('')

        # Output
        lines.append('#--- Output -----------------------------------------------------------------')
        if op.output_mode == "table" and op.table_columns:
            if "count" in (op.version_guard_keys or []):
                lines.append('Write-Output "Total: $($response.count)"')
            lines.append(f'$response.{op.list_key} | ForEach-Object {{')
            lines.append('    [PSCustomObject]@{')
            for col in op.table_columns:
                ps_prop = _to_pascal(col)
                lines.append(f'        {ps_prop} = $_.{col}')
            lines.append('    }')
            lines.append('} | Format-Table -AutoSize')
        elif op.output_mode == "message" and op.output_message:
            import re
            msg = op.output_message
            msg = re.sub(r'\{(\w+)\}', r'$($response.\1)', msg)
            lines.append(f'Write-Host "{msg}"')
            lines.append('$response | ConvertTo-Json -Depth 5')
        else:
            lines.append('$response | ConvertTo-Json -Depth 5')

    lines.append('')
    return '\n'.join(lines)


def _to_pascal(snake: str) -> str:
    """Convert snake_case to PascalCase."""
    return ''.join(word.capitalize() for word in snake.split('_'))


def _resolve_body_source_ps(bf, op):
    """Resolve a body field source to a PowerShell expression."""
    if bf.source.startswith("param:"):
        pname = bf.source.split(":", 1)[1]
        for p in op.params:
            if p.name == pname:
                ps_name = p.ps_name or _to_pascal(p.name)
                return f'${ps_name}'
        return f'${_to_pascal(pname)}'
    elif bf.source.startswith("literal:"):
        val = bf.source.split(":", 1)[1]
        return f"'{val}'"
    return f"'{bf.source}'"
