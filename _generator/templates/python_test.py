"""
Python test template for Azure DevOps API operations.
"""

from _generator.operation_def import OperationDef


def render_python_test(op: OperationDef) -> str:
    """Render a pytest test file from an OperationDef."""
    lines = []

    lines.append('#!/usr/bin/env python3')
    lines.append('# AUTO-GENERATED by _generator — do not edit by hand.')
    lines.append(f'"""')
    lines.append(f'Offline unit tests for {op.python_script_name}')
    lines.append(f'')
    lines.append(f'Validates:')
    lines.append(f'  - Correct URL construction')
    lines.append(f'  - Correct Authorization header')
    lines.append(f'  - Successful response parsing ({op.success_status})')
    lines.append(f'  - Exit when required env vars are missing')
    lines.append(f'"""')
    lines.append('')
    lines.append('import json')
    lines.append('import os')
    lines.append('import subprocess')
    lines.append('import sys')
    lines.append('from pathlib import Path')
    lines.append('')
    lines.append('import pytest')
    lines.append('import responses')
    lines.append('')
    lines.append('FIXTURES = Path(__file__).parent / "fixtures"')
    lines.append(f'SCRIPT = str(Path(__file__).resolve().parents[1] / "{op.python_script_name}")')
    lines.append('')

    # Determine domain marker
    domain_marker = op.domain.lower()
    if domain_marker == "workitemtracking":
        domain_marker = "wit"

    # Helper to run script as subprocess
    lines.append('# ---------------------------------------------------------------------------')
    lines.append('# Helpers')
    lines.append('# ---------------------------------------------------------------------------')
    lines.append('')
    lines.append('def _run_script(env_override=None, extra_args=None, expect_fail=False):')
    lines.append('    """Run the script as a subprocess with the given env."""')
    lines.append('    env = {')
    lines.append('        "AZURE_DEVOPS_ORG": "testorg",')
    lines.append('        "AZURE_DEVOPS_PAT": "fakepat1234567890",')
    if op.project_scoped:
        lines.append('        "PROJECT_ID": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",')
    # Add extra env params
    _test_already_handled = {"AZURE_DEVOPS_ORG", "AZURE_DEVOPS_PAT"}
    if op.project_scoped:
        _test_already_handled.add("PROJECT_ID")
    for p in op.params:
        if not p.cli_flag and p.env_var not in _test_already_handled:
            lines.append(f'        "{p.env_var}": "test-value-{p.name}",')
    lines.append('        "PATH": os.environ.get("PATH", ""),')
    lines.append('        "PYTHONPATH": os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", ".."),')
    lines.append('    }')
    lines.append('    if env_override:')
    lines.append('        env.update(env_override)')
    lines.append('    env = {k: v for k, v in env.items() if v is not None}')
    lines.append('')
    lines.append('    cmd = [sys.executable, SCRIPT]')
    lines.append('    if extra_args:')
    lines.append('        cmd.extend(extra_args)')
    lines.append('')
    lines.append('    result = subprocess.run(')
    lines.append('        cmd,')
    lines.append('        capture_output=True,')
    lines.append('        text=True,')
    lines.append('        env=env,')
    lines.append('        timeout=30,')
    lines.append('    )')
    lines.append('    if not expect_fail:')
    lines.append('        assert result.returncode == 0, (')
    lines.append('            f"Script failed (rc={result.returncode}):\\n"')
    lines.append('            f"STDOUT: {result.stdout}\\nSTDERR: {result.stderr}"')
    lines.append('        )')
    lines.append('    return result')
    lines.append('')
    lines.append('')

    # Env validation tests
    opclass = _to_class_name(op.operation)
    lines.append(f'class Test{opclass}EnvValidation:')
    lines.append(f'    """Test that the script fails gracefully when env vars are missing."""')
    lines.append('')

    lines.append(f'    @pytest.mark.offline')
    lines.append(f'    @pytest.mark.{domain_marker}')
    lines.append(f'    def test_missing_org_exits(self):')
    lines.append(f'        result = _run_script(')
    lines.append(f'            env_override={{"AZURE_DEVOPS_ORG": None}},')
    lines.append(f'            expect_fail=True,')
    lines.append(f'        )')
    lines.append(f'        assert result.returncode != 0')
    lines.append(f'        assert "AZURE_DEVOPS_ORG" in result.stderr or "AZURE_DEVOPS_ORG" in result.stdout')
    lines.append('')

    lines.append(f'    @pytest.mark.offline')
    lines.append(f'    @pytest.mark.{domain_marker}')
    lines.append(f'    def test_missing_pat_exits(self):')
    lines.append(f'        result = _run_script(')
    lines.append(f'            env_override={{"AZURE_DEVOPS_PAT": None}},')
    lines.append(f'            expect_fail=True,')
    lines.append(f'        )')
    lines.append(f'        assert result.returncode != 0')
    lines.append(f'        assert "AZURE_DEVOPS_PAT" in result.stderr or "AZURE_DEVOPS_PAT" in result.stdout')
    lines.append('')

    if op.project_scoped:
        lines.append(f'    @pytest.mark.offline')
        lines.append(f'    @pytest.mark.{domain_marker}')
        lines.append(f'    def test_missing_project_id_exits(self):')
        lines.append(f'        result = _run_script(')
        lines.append(f'            env_override={{"PROJECT_ID": None}},')
        lines.append(f'            expect_fail=True,')
        lines.append(f'        )')
        lines.append(f'        assert result.returncode != 0')
        lines.append(f'        assert "PROJECT_ID" in (result.stderr + result.stdout)')
        lines.append('')

    for p in op.params:
        if p.required and not p.cli_flag and p.env_var not in _test_already_handled:
            lines.append(f'    @pytest.mark.offline')
            lines.append(f'    @pytest.mark.{domain_marker}')
            lines.append(f'    def test_missing_{p.name}_exits(self):')
            lines.append(f'        result = _run_script(')
            lines.append(f'            env_override={{"{p.env_var}": None}},')
            lines.append(f'            expect_fail=True,')
            lines.append(f'        )')
            lines.append(f'        assert result.returncode != 0')
            lines.append(f'        assert "{p.env_var}" in result.stderr or "{p.env_var}" in result.stdout')
            lines.append('')

    lines.append('')

    # URL and auth tests
    lines.append(f'class Test{opclass}URLAndAuth:')
    lines.append(f'    """Validate URL construction and auth header using in-process mocking."""')
    lines.append('')

    # Build expected URL for the test
    api_version = op.api_version
    url_path = op.url_path
    for p in op.params:
        placeholder = '{' + p.name + '}'
        if placeholder in url_path:
            url_path = url_path.replace(placeholder, f'test-value-{p.name}')

    if op.project_scoped:
        expected_url = f'https://{op.base_host}/testorg/a1b2c3d4-e5f6-7890-abcd-ef1234567890/{url_path}?api-version={api_version}'
    else:
        expected_url = f'https://{op.base_host}/testorg/{url_path}?api-version={api_version}'

    lines.append(f'    @pytest.mark.offline')
    lines.append(f'    @pytest.mark.{domain_marker}')
    lines.append(f'    @responses.activate')
    lines.append(f'    def test_correct_url_and_auth_header(self):')
    lines.append(f'        """Verify the script builds the right URL and Authorization header."""')
    lines.append(f'        import base64')
    lines.append(f'')
    lines.append(f'        org = "testorg"')
    lines.append(f'        pat = "fakepat1234567890"')
    lines.append(f'        expected_url = "{expected_url}"')
    lines.append(f'')
    method_const = f'responses.{op.http_method}'
    if op.success_status == 204:
        # HTTP 204 No Content — do NOT attach a body or the responses
        # library will set Content-Length, causing ChunkedEncodingError.
        lines.append(f'        responses.add({method_const}, expected_url, status=204)')
    else:
        lines.append(f'        fixture = json.loads((FIXTURES / "{op.fixture_filename}").read_text())')
        lines.append(f'        responses.add({method_const}, expected_url, json=fixture, status={op.success_status})')
    lines.append(f'')
    lines.append(f'        import requests as req')
    lines.append(f'')
    lines.append(f'        cred = base64.b64encode(f":{{pat}}".encode("ascii")).decode("ascii")')
    lines.append(f'        headers = {{')
    lines.append(f'            "Authorization": f"Basic {{cred}}",')
    lines.append(f'            "Content-Type": "application/json",')
    lines.append(f'        }}')

    if op.body_fields:
        lines.append(f'        resp = req.{op.http_method.lower()}(expected_url, headers=headers, json={{}}, timeout=30)')
    else:
        lines.append(f'        resp = req.{op.http_method.lower()}(expected_url, headers=headers, timeout=30)')

    lines.append(f'')
    lines.append(f'        assert resp.status_code == {op.success_status}')
    lines.append(f'        assert len(responses.calls) == 1')
    lines.append(f'        sent_auth = responses.calls[0].request.headers["Authorization"]')
    lines.append(f'        assert sent_auth.startswith("Basic ")')
    lines.append('')
    lines.append('')

    # HTTP error tests
    lines.append(f'class Test{opclass}HTTPErrors:')
    lines.append(f'    """Validate behaviour on error status codes."""')
    lines.append('')

    for status, name in [(401, 'unauthorized'), (404, 'not_found')]:
        lines.append(f'    @pytest.mark.offline')
        lines.append(f'    @pytest.mark.{domain_marker}')
        lines.append(f'    @responses.activate')
        lines.append(f'    def test_{status}_{name}(self):')
        lines.append(f'        url = "{expected_url}"')
        lines.append(f'        responses.add({method_const}, url, json={{"message": "{name}"}}, status={status})')
        lines.append(f'')
        lines.append(f'        import requests as req')
        lines.append(f'')
        if op.body_fields:
            lines.append(f'        resp = req.{op.http_method.lower()}(url, headers={{"Authorization": "Basic fake"}}, json={{}}, timeout=30)')
        else:
            lines.append(f'        resp = req.{op.http_method.lower()}(url, headers={{"Authorization": "Basic fake"}}, timeout=30)')
        lines.append(f'        assert resp.status_code == {status}')
        lines.append('')

    lines.append('')
    return '\n'.join(lines)


def _to_class_name(snake: str) -> str:
    """Convert snake_case to PascalCase class name."""
    return ''.join(word.capitalize() for word in snake.split('_'))
