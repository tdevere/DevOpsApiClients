"""
Python implementation template for Azure DevOps API operations.

AUTO-GENERATED files include a header comment marking them as such.
Generated scripts use _shared/ helpers for auth, logging, and HTTP.
"""

from _generator.operation_def import OperationDef


def render_python(op: OperationDef) -> str:
    """Render a Python implementation script from an OperationDef."""
    lines = []

    # Shebang + docstring
    lines.append('#!/usr/bin/env python3')
    lines.append('# AUTO-GENERATED by _generator — do not edit by hand.')
    lines.append('# Source of truth: _generator/definitions/')
    lines.append(f'"""')
    lines.append(f'{op.synopsis}')
    lines.append(f'')
    lines.append(f'API:  {op.http_method} {{org}}/{op.url_path}?api-version={op.api_version}')
    lines.append(f'Auth: Basic (PAT)')
    lines.append(f'')
    lines.append(f'Docs: {op.docs_url}')
    lines.append(f'"""')
    lines.append('')

    # Imports
    imports = ['import json', 'import os', 'import sys']
    if op.body_fields and any(p.cli_flag for p in op.params):
        imports.insert(0, 'import argparse')
    lines.extend(imports)
    lines.append('')
    lines.append('# Add project root to path for shared helpers')
    lines.append("sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..'))")
    lines.append('')
    lines.append('import requests')
    lines.append('')
    lines.append('from _shared.auth import build_auth_header, get_env_or_exit')
    lines.append('from _shared.logging_utils import AdoLogger')
    lines.append('from _shared.http_client import build_url, execute_request, version_guard')
    lines.append('')

    # Configuration
    lines.append('# ' + '-' * 75)
    lines.append('# Configuration')
    lines.append('# ' + '-' * 75)
    lines.append(f'API_VERSION = "{op.api_version}"')
    lines.append('')

    # Standard env vars — use get_env_or_exit for required ones
    lines.append('ORGANIZATION = get_env_or_exit("AZURE_DEVOPS_ORG", "organisation slug")')
    lines.append('PAT = get_env_or_exit("AZURE_DEVOPS_PAT", "Personal Access Token")')
    if op.project_scoped:
        lines.append('PROJECT_ID = get_env_or_exit("PROJECT_ID", "project name or GUID")')

    # Extra params from env — skip those already handled above
    _py_already_handled = {"AZURE_DEVOPS_ORG", "AZURE_DEVOPS_PAT"}
    if op.project_scoped:
        _py_already_handled.add("PROJECT_ID")
    for p in op.params:
        if not p.cli_flag:
            if p.env_var not in _py_already_handled:
                # Escape description for safe embedding in double-quoted string
                safe_desc = p.description.replace('"', "'").replace("\n", " ")
                lines.append(f'{p.env_var} = get_env_or_exit("{p.env_var}", "{safe_desc}")')
    lines.append('')

    # Argparse for CLI params
    cli_params = [p for p in op.params if p.cli_flag]
    if cli_params:
        lines.append('# ' + '-' * 75)
        lines.append('# CLI arguments')
        lines.append('# ' + '-' * 75)
        safe_syn = op.synopsis.replace('"', "'").replace('\n', ' ')
        lines.append(f'parser = argparse.ArgumentParser(description="{safe_syn}")')
        for p in cli_params:
            req = "True" if p.required else "False"
            safe_pdesc = p.description.replace('"', "'").replace('\n', ' ')
            lines.append(f'parser.add_argument("{p.cli_flag}", required={req}, help="{safe_pdesc}")')
        lines.append('args = parser.parse_args()')
        lines.append('')

    # Auth header & logging
    lines.append('# ' + '-' * 75)
    lines.append('# Auth header & logging')
    lines.append('# ' + '-' * 75)
    lines.append('HEADERS = build_auth_header(PAT)')
    lines.append(f'logger = AdoLogger("{op.operation}", PAT)')
    safe_log_synopsis = op.synopsis.replace('"', "'").replace('\n', ' ')
    lines.append(f'logger.info("{safe_log_synopsis}")')
    lines.append('')

    # Request body
    if op.body_fields:
        lines.append('# ' + '-' * 75)
        lines.append('# Request body')
        lines.append('# ' + '-' * 75)
        lines.append('body = {')
        for bf in op.body_fields:
            val = _resolve_body_source_py(bf, op)
            if '.' in bf.json_path:
                pass
            else:
                lines.append(f'    "{bf.json_path}": {val},')
        # Handle nested fields
        nested = {}
        for bf in op.body_fields:
            if '.' in bf.json_path:
                parts = bf.json_path.split('.', 1)
                parent = parts[0]
                child = parts[1]
                if parent not in nested:
                    nested[parent] = []
                nested[parent].append((child, _resolve_body_source_py(bf, op)))
        for parent, children in nested.items():
            lines.append(f'    "{parent}": {{')
            for child_name, child_val in children:
                lines.append(f'        "{child_name}": {child_val},')
            lines.append(f'    }},')
        lines.append('}')
        lines.append('')

    # URL construction
    lines.append('# ' + '-' * 75)
    lines.append('# API call')
    lines.append('# ' + '-' * 75)

    # Build URL path with param substitution
    url_path = op.url_path
    for p in op.params:
        placeholder = '{' + p.name + '}'
        if placeholder in url_path:
            if p.cli_flag:
                url_path = url_path.replace(placeholder, '{args.' + p.cli_flag.lstrip('-').replace('-', '_') + '}')
            else:
                url_path = url_path.replace(placeholder, '{' + p.env_var + '}')

    # Use build_url helper
    if op.project_scoped and op.base_host != 'dev.azure.com':
        lines.append(f'url = build_url(ORGANIZATION, f"{url_path}", API_VERSION, project=PROJECT_ID, base_host="{op.base_host}")')
    elif op.project_scoped:
        lines.append(f'url = build_url(ORGANIZATION, f"{url_path}", API_VERSION, project=PROJECT_ID)')
    elif op.base_host != 'dev.azure.com':
        lines.append(f'url = build_url(ORGANIZATION, f"{url_path}", API_VERSION, base_host="{op.base_host}")')
    else:
        lines.append(f'url = build_url(ORGANIZATION, f"{url_path}", API_VERSION)')
    lines.append('logger.info(f"{0} {{url}}")'.format(op.http_method))
    lines.append('')

    # HTTP call via execute_request
    method_upper = op.http_method
    if op.body_fields:
        if op.success_status != 200:
            lines.append(f'response = execute_request("{method_upper}", url, HEADERS, body=body, expected_status={op.success_status})')
        else:
            lines.append(f'response = execute_request("{method_upper}", url, HEADERS, body=body)')
    else:
        if op.success_status != 200:
            lines.append(f'response = execute_request("{method_upper}", url, HEADERS, expected_status={op.success_status})')
        else:
            lines.append(f'response = execute_request("{method_upper}", url, HEADERS)')
    lines.append('')

    # Handle 204 No Content
    if op.success_status == 204:
        lines.append('# ' + '-' * 75)
        lines.append('# Output — DELETE returns 204 No Content on success')
        lines.append('# ' + '-' * 75)
        lines.append(f'if response.status_code == 204:')
        if op.output_message:
            lines.append(f'    logger.info("{op.output_message}")')
            lines.append(f'    print("{op.output_message}")')
        else:
            lines.append(f'    logger.info("Operation completed successfully.")')
            lines.append(f'    print("Operation completed successfully.")')
        lines.append('else:')
        lines.append('    logger.error(f"Unexpected status code: {response.status_code}")')
        lines.append('    print(f"Unexpected status code: {response.status_code}", file=sys.stderr)')
        lines.append('    if response.text:')
        lines.append('        print(response.text)')
    else:
        lines.append('data = response.json()')
        lines.append('')

        # Version guard
        if op.version_guard_keys:
            lines.append('# ' + '-' * 75)
            lines.append('# Version guard')
            lines.append('# ' + '-' * 75)
            keys_list = repr(op.version_guard_keys)
            lines.append(f'version_guard(data, {keys_list}, API_VERSION)')
            lines.append('')

        # Log summary
        if "count" in (op.version_guard_keys or []):
            lines.append('logger.info(f"Retrieved {data.get(\'count\', \'?\')} items")')
            lines.append('')

        # Output
        lines.append('# ' + '-' * 75)
        lines.append('# Output')
        lines.append('# ' + '-' * 75)
        if op.output_mode == "table" and op.table_columns:
            if "count" in (op.version_guard_keys or []):
                lines.append("print(f\"Total: {data.get('count', 'N/A')}\\n\")")
            lines.append(f'for item in data.get("{op.list_key}", []):')
            access_parts = []
            for c in op.table_columns:
                access_parts.append(f'item.get("{c}", "N/A")')
            lines.append(f'    cols = [{", ".join(access_parts)}]')
            lines.append('    print("  " + "  ".join(str(c) for c in cols))')
        elif op.output_mode == "message" and op.output_message:
            msg = op.output_message.replace('{', '{data.get("').replace('}', '", "N/A")}')
            lines.append(f'print(f"{msg}")')
            lines.append('print(json.dumps(data, indent=2))')
        else:
            lines.append('print(json.dumps(data, indent=2))')

    lines.append('')
    return '\n'.join(lines)


def _resolve_body_source_py(bf, op):
    """Resolve a body field source to a Python expression."""
    if bf.source.startswith("param:"):
        pname = bf.source.split(":", 1)[1]
        # Find the param
        for p in op.params:
            if p.name == pname:
                if p.cli_flag:
                    flag = p.cli_flag.lstrip('-').replace('-', '_')
                    return f'args.{flag}'
                else:
                    return p.env_var
        return f'"{pname}"'
    elif bf.source.startswith("literal:"):
        val = bf.source.split(":", 1)[1]
        return f'"{val}"'
    return f'"{bf.source}"'
