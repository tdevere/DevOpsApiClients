# =============================================================================
# Azure DevOps 7.2 API Clients — CI Test & Release Pipeline
#
# Two-tier testing:
#   T1: Offline unit tests  — every push/PR, no secrets needed
#   T2: Live integration    — main push, workflow_dispatch, or 'run-live-tests' label
#
# Path-based scoping:
#   Only runs tests for API domains that changed (e.g., Core/, Git/).
#   Changes to _shared/ or .github/ trigger the full suite.
#
# Required secrets (T2 only):
#   AZURE_DEVOPS_PAT  — Personal Access Token
#   AZURE_DEVOPS_ORG  — Organisation name
#   PROJECT_ID        — Target project name or GUID
#   ADO_TEST_PROJECT  — Dedicated sacrificial project for mutations
# =============================================================================
name: CI Test & Release

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

# ═══════════════════════════════════════════════════════════════════════════════
jobs:

  # -------------------------------------------------------------------------
  # 1. Lint — always runs, no secrets needed
  # -------------------------------------------------------------------------
  lint:
    name: "Lint & Syntax"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: "Python — syntax check all .py files"
        run: |
          echo "=== Python syntax check ==="
          find . -name '*.py' -not -path './.git/*' -print -exec python -m py_compile {} \;
          echo "All Python files compile ✓"

      - name: "Bash — syntax check all .sh files"
        run: |
          echo "=== Bash syntax check ==="
          find . -name '*.sh' -not -path './.git/*' -print -exec bash -n {} \;
          echo "All Bash files pass syntax check ✓"

      - name: "PowerShell — syntax parse all .ps1 files"
        shell: pwsh
        run: |
          Write-Host "=== PowerShell syntax check ==="
          Get-ChildItem -Recurse -Filter '*.ps1' | ForEach-Object {
              $tokens = $null; $errors = $null
              [System.Management.Automation.Language.Parser]::ParseFile(
                  $_.FullName, [ref]$tokens, [ref]$errors
              ) | Out-Null
              if ($errors.Count -gt 0) {
                  Write-Error "Parse errors in $($_.FullName): $($errors | Out-String)"
                  exit 1
              }
              Write-Host "  OK  $($_.FullName)"
          }
          Write-Host "All PowerShell files parse ✓"

  # -------------------------------------------------------------------------
  # 2. Detect changes — path-based scoping
  # -------------------------------------------------------------------------
  detect-changes:
    name: "Detect Changed Domains"
    runs-on: ubuntu-latest
    outputs:
      core: ${{ steps.filter.outputs.core }}
      git: ${{ steps.filter.outputs.git }}
      build: ${{ steps.filter.outputs.build }}
      wit: ${{ steps.filter.outputs.wit }}
      pipelines: ${{ steps.filter.outputs.pipelines }}
      distributedtask: ${{ steps.filter.outputs.distributedtask }}
      policy: ${{ steps.filter.outputs.policy }}
      hooks: ${{ steps.filter.outputs.hooks }}
      wiki: ${{ steps.filter.outputs.wiki }}
      shared: ${{ steps.filter.outputs.shared }}
      any_domain: ${{ steps.check.outputs.any_domain }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            core:
              - 'Core/**'
            git:
              - 'Git/**'
            build:
              - 'Build/**'
            wit:
              - 'WorkItemTracking/**'
            pipelines:
              - 'Pipelines/**'
            distributedtask:
              - 'DistributedTask/**'
            policy:
              - 'Policy/**'
            hooks:
              - 'Hooks/**'
            wiki:
              - 'Wiki/**'
            shared:
              - '_shared/**'
              - '.github/workflows/**'
              - 'pytest.ini'

      - name: "Check if any domain changed"
        id: check
        run: |
          if [[ "${{ steps.filter.outputs.core }}" == "true" || \
                "${{ steps.filter.outputs.git }}" == "true" || \
                "${{ steps.filter.outputs.build }}" == "true" || \
                "${{ steps.filter.outputs.wit }}" == "true" || \
                "${{ steps.filter.outputs.pipelines }}" == "true" || \
                "${{ steps.filter.outputs.distributedtask }}" == "true" || \
                "${{ steps.filter.outputs.policy }}" == "true" || \
                "${{ steps.filter.outputs.hooks }}" == "true" || \
                "${{ steps.filter.outputs.wiki }}" == "true" || \
                "${{ steps.filter.outputs.shared }}" == "true" || \
                "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "any_domain=true" >> "$GITHUB_OUTPUT"
          else
            echo "any_domain=false" >> "$GITHUB_OUTPUT"
          fi

  # -------------------------------------------------------------------------
  # 3. Offline unit tests — always runs (no secrets needed)
  # -------------------------------------------------------------------------
  test-offline:
    name: "Test — Offline"
    runs-on: ubuntu-latest
    needs: [lint, detect-changes]
    if: needs.detect-changes.outputs.any_domain == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: "Install Python test dependencies"
        run: pip install requests responses pytest

      - name: "Run pytest offline tests (scoped)"
        run: |
          MARKERS="offline"

          # Scope to changed domains (or run all if shared changed / dispatch)
          if [[ "${{ needs.detect-changes.outputs.shared }}" == "true" || \
                "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Running ALL offline tests (shared files changed or dispatch)"
            pytest -m "$MARKERS" -v --tb=short
          else
            PATHS=""
            [[ "${{ needs.detect-changes.outputs.core }}" == "true" ]]            && PATHS="$PATHS Core/"
            [[ "${{ needs.detect-changes.outputs.git }}" == "true" ]]             && PATHS="$PATHS Git/"
            [[ "${{ needs.detect-changes.outputs.build }}" == "true" ]]           && PATHS="$PATHS Build/"
            [[ "${{ needs.detect-changes.outputs.wit }}" == "true" ]]             && PATHS="$PATHS WorkItemTracking/"
            [[ "${{ needs.detect-changes.outputs.pipelines }}" == "true" ]]       && PATHS="$PATHS Pipelines/"
            [[ "${{ needs.detect-changes.outputs.distributedtask }}" == "true" ]] && PATHS="$PATHS DistributedTask/"
            [[ "${{ needs.detect-changes.outputs.policy }}" == "true" ]]          && PATHS="$PATHS Policy/"
            [[ "${{ needs.detect-changes.outputs.hooks }}" == "true" ]]           && PATHS="$PATHS Hooks/"
            [[ "${{ needs.detect-changes.outputs.wiki }}" == "true" ]]            && PATHS="$PATHS Wiki/"

            if [[ -n "$PATHS" ]]; then
              echo "Running offline tests for:$PATHS"
              pytest -m "$MARKERS" -v --tb=short $PATHS
            else
              echo "No test paths matched — skipping."
            fi
          fi

      - name: "Install Pester v5"
        shell: pwsh
        run: |
          # Ensure Pester v5 is available — the OS default on Ubuntu is v3.
          $installed = (Get-Module Pester -ListAvailable | Sort-Object Version -Descending | Select-Object -First 1).Version
          if (-not $installed -or $installed.Major -lt 5) {
            Write-Host "Installing Pester v5..."
            Install-Module Pester -Force -SkipPublisherCheck -MinimumVersion 5.0 -Scope CurrentUser
          } else {
            Write-Host "Pester $installed already satisfies v5 requirement."
          }

      - name: "Run Pester offline tests"
        shell: pwsh
        run: |
          Import-Module Pester -MinimumVersion 5.0 -Force
          $config = New-PesterConfiguration
          $config.Filter.Tag = 'Offline'
          $config.Output.Verbosity = 'Detailed'
          $config.Run.Exit = $true

          # Scope to changed domains
          $paths = @()
          if ('${{ needs.detect-changes.outputs.shared }}' -eq 'true' -or
              '${{ github.event_name }}' -eq 'workflow_dispatch') {
              $paths = @('./Core', './Git', './Build', './WorkItemTracking', './Pipelines', './DistributedTask', './Policy', './Hooks', './Wiki')
          } else {
              if ('${{ needs.detect-changes.outputs.core }}' -eq 'true')            { $paths += './Core' }
              if ('${{ needs.detect-changes.outputs.git }}' -eq 'true')             { $paths += './Git' }
              if ('${{ needs.detect-changes.outputs.build }}' -eq 'true')           { $paths += './Build' }
              if ('${{ needs.detect-changes.outputs.wit }}' -eq 'true')             { $paths += './WorkItemTracking' }
              if ('${{ needs.detect-changes.outputs.pipelines }}' -eq 'true')       { $paths += './Pipelines' }
              if ('${{ needs.detect-changes.outputs.distributedtask }}' -eq 'true') { $paths += './DistributedTask' }
              if ('${{ needs.detect-changes.outputs.policy }}' -eq 'true')          { $paths += './Policy' }
              if ('${{ needs.detect-changes.outputs.hooks }}' -eq 'true')           { $paths += './Hooks' }
              if ('${{ needs.detect-changes.outputs.wiki }}' -eq 'true')            { $paths += './Wiki' }
          }

          if ($paths.Count -eq 0) {
              Write-Host "No Pester test paths matched — skipping."
              exit 0
          }

          $config.Run.Path = $paths
          Write-Host "Running Pester offline tests for: $($paths -join ', ')"
          Invoke-Pester -Configuration $config

      - name: "Run bats offline tests"
        run: |
          # Install bats-core if not available
          if ! command -v bats &> /dev/null; then
            echo "Installing bats-core..."
            sudo apt-get update -qq && sudo apt-get install -y -qq bats
          fi

          # Scope to changed domains
          BATS_FILES=""
          if [[ "${{ needs.detect-changes.outputs.shared }}" == "true" || \
                "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            BATS_FILES=$(find . -name '*.bats' -not -path './.git/*')
          else
            [[ "${{ needs.detect-changes.outputs.core }}" == "true" ]]            && BATS_FILES="$BATS_FILES $(find Core/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.git }}" == "true" ]]             && BATS_FILES="$BATS_FILES $(find Git/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.build }}" == "true" ]]           && BATS_FILES="$BATS_FILES $(find Build/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.wit }}" == "true" ]]             && BATS_FILES="$BATS_FILES $(find WorkItemTracking/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.pipelines }}" == "true" ]]       && BATS_FILES="$BATS_FILES $(find Pipelines/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.distributedtask }}" == "true" ]] && BATS_FILES="$BATS_FILES $(find DistributedTask/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.policy }}" == "true" ]]          && BATS_FILES="$BATS_FILES $(find Policy/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.hooks }}" == "true" ]]           && BATS_FILES="$BATS_FILES $(find Hooks/ -name '*.bats' 2>/dev/null)"
            [[ "${{ needs.detect-changes.outputs.wiki }}" == "true" ]]            && BATS_FILES="$BATS_FILES $(find Wiki/ -name '*.bats' 2>/dev/null)"
          fi

          BATS_FILES=$(echo "$BATS_FILES" | xargs)
          if [[ -n "$BATS_FILES" ]]; then
            echo "Running bats tests: $BATS_FILES"
            bats $BATS_FILES
          else
            echo "No bats tests found — skipping."
          fi

  # -------------------------------------------------------------------------
  # 4. Live integration tests — gated (secrets required)
  #    Runs on: main push, workflow_dispatch, or PR with 'run-live-tests' label
  # -------------------------------------------------------------------------
  test-live:
    name: "Test — Live"
    runs-on: ubuntu-latest
    needs: [test-offline, detect-changes]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch' ||
      contains(github.event.pull_request.labels.*.name, 'run-live-tests')
    env:
      AZURE_DEVOPS_PAT: ${{ secrets.AZURE_DEVOPS_PAT }}
      AZURE_DEVOPS_ORG: ${{ secrets.AZURE_DEVOPS_ORG }}
      PROJECT_ID:       ${{ secrets.PROJECT_ID }}
      ADO_TEST_PROJECT: ${{ secrets.ADO_TEST_PROJECT }}
    steps:
      - uses: actions/checkout@v4

      - name: "Validate secrets"
        run: |
          [[ -z "$AZURE_DEVOPS_PAT" ]] && echo "::error::AZURE_DEVOPS_PAT not set" && exit 1
          [[ -z "$AZURE_DEVOPS_ORG" ]] && echo "::error::AZURE_DEVOPS_ORG not set" && exit 1
          [[ -z "$PROJECT_ID" ]]       && echo "::error::PROJECT_ID not set"       && exit 1
          echo "All secrets present ✓"

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: "Install dependencies"
        run: pip install requests

      # --- PowerShell live tests ---
      - name: "PowerShell — List Projects"
        shell: pwsh
        run: ./Core/Projects/List-Projects.ps1 -Verbose

      - name: "PowerShell — Get Project"
        shell: pwsh
        run: ./Core/Projects/Get-Project.ps1 -Verbose

      - name: "PowerShell — Update Project"
        shell: pwsh
        run: |
          $ts = Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ'
          ./Core/Projects/Update-Project.ps1 -NewDescription "CI live test at $ts" -Verbose

      # --- Python live tests ---
      - name: "Python — List Projects"
        run: python Core/Projects/list_projects.py

      - name: "Python — Get Project"
        run: python Core/Projects/get_project.py

      - name: "Python — Update Project"
        run: |
          python Core/Projects/update_project.py \
            --description "CI live test at $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      # --- Bash/cURL live tests ---
      - name: "cURL — List Projects"
        run: bash Core/Projects/list_projects.sh

      - name: "cURL — Get Project"
        run: bash Core/Projects/get_project.sh

      - name: "cURL — Update Project"
        run: |
          bash Core/Projects/update_project.sh \
            "{\"description\":\"CI live test at $(date -u +%Y-%m-%dT%H:%M:%SZ)\"}"

  # =========================================================================
  # 5. Release — main push only, after all tests pass
  # =========================================================================
  release:
    name: "Create Release"
    runs-on: ubuntu-latest
    needs: [lint, test-offline, test-live]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Determine next version"
        id: version
        run: |
          git fetch --tags
          LATEST_TAG=$(git tag --list 'v*' --sort=-version:refname | head -n1)
          if [[ -z "$LATEST_TAG" ]]; then
            LATEST_TAG="v0.0.0"
            echo "No existing tags — starting from v0.0.0"
          else
            echo "Latest tag: $LATEST_TAG"
          fi
          VERSION="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          PATCH=$((PATCH + 1))
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "Next version: $NEW_TAG"
          echo "tag=$NEW_TAG"         >> "$GITHUB_OUTPUT"
          echo "previous=$LATEST_TAG" >> "$GITHUB_OUTPUT"

      - name: "Build release archive"
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          ARCHIVE="DevOpsApiClients-${TAG}.tar.gz"
          tar czf "/tmp/${ARCHIVE}" --exclude='.git' --exclude='.github' -C "$GITHUB_WORKSPACE" .
          cp "/tmp/${ARCHIVE}" "${GITHUB_WORKSPACE}/${ARCHIVE}"
          echo "ARCHIVE=${ARCHIVE}" >> "$GITHUB_ENV"

      - name: "Create Git tag"
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG — all tests passed"
          git push origin "$TAG"

      - name: "Create GitHub Release"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: "Release ${{ steps.version.outputs.tag }}"
          generate_release_notes: true
          body: |
            ## Azure DevOps 7.2 API Clients — ${{ steps.version.outputs.tag }}

            All tests passed: **offline unit tests** (T1) + **live integration** (T2).

            ### Tested API Areas
            - **Core** — Projects (List, Get, Update) · Teams (List)
            - **Git** — Repositories (List, Get, Create, Delete) · PullRequests (List, Get, Create, Update) · PullRequestThreads (List) · Commits (List, Get) · Pushes (List) · Refs (List)
            - **Build** — Definitions (List, Get) · Builds (List, Get) · Artifacts (List)
            - **Pipelines** — Pipelines (List, Get, Run) · Runs (List, Get)
            - **WorkItemTracking** — WorkItems (Get, Create, Update, Batch Get, Delete) · Wiql (Query) · Fields (List) · WorkItemTypes (List) · Comments (List, Add) · Queries (List, Get)
            - **DistributedTask** — Pools (List) · VariableGroups (List, Get) · Environments (List, Get)
            - **Policy** — Configurations (List, Get)
            - **Hooks** — Subscriptions (List, Get)
            - **Wiki** — Wikis (List, Get)

            ### Test Tiers
            | Tier | Status |
            |------|--------|
            | T1 Offline (pytest + Pester + bats) | ✅ Passed |
            | T2 Live (PowerShell + Python + cURL) | ✅ Passed |
          files: |
            ${{ env.ARCHIVE }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
