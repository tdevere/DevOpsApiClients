# =============================================================================
# Auto-Heal â€” Detect CI failures and create fix issues for Copilot
#
# Triggers after any CI Test & Release run completes with failure on main.
# Parses test failure logs, creates a structured GitHub Issue with
# reproduction steps and acceptance criteria, then assigns to copilot.
#
# Guard rails:
#   - Only triggers on main branch failures (not PR branches)
#   - Dedup: skips if an open auto-heal issue already exists
#   - Non-fatal copilot assignment (issue created regardless)
# =============================================================================
name: Auto-Heal Test Failures

on:
  workflow_run:
    workflows: ["CI Test & Release"]
    types: [completed]

permissions:
  issues: write
  contents: read
  actions: read

jobs:
  check-and-heal:
    name: "Detect & Dispatch Fix"
    if: >-
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.head_branch == 'main'
    runs-on: ubuntu-latest
    steps:
      # â”€â”€ 1. Parse failure logs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Download and parse CI failure logs"
        id: logs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ github.event.workflow_run.id }}
        run: |
          echo "Fetching logs for CI run $RUN_ID"

          # Download failed job logs
          gh run view "$RUN_ID" \
            --repo "${{ github.repository }}" \
            --log-failed > /tmp/failed_logs.txt 2>/dev/null || true

          LOG_SIZE=$(wc -c < /tmp/failed_logs.txt | tr -d ' ')
          echo "Log size: $LOG_SIZE bytes"

          if [[ "$LOG_SIZE" -lt 10 ]]; then
            echo "No logs retrieved â€” workflow may have been cancelled"
            echo "total_failures=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # â”€â”€ Extract pytest failures â”€â”€
          # GH Actions logs have prefixes: "Job\tStep\tTimestamp test::class FAILED [%]"
          grep -oP '\S+\.py::\S+ FAILED' /tmp/failed_logs.txt \
            | sed 's/ FAILED$//' \
            > /tmp/pytest_failures.txt 2>/dev/null || true
          PYTEST_COUNT=$(wc -l < /tmp/pytest_failures.txt | tr -d ' ')

          # Also grab the summary line (e.g. "54 failed, 7511 passed")
          PYTEST_SUMMARY=$(grep -oP '\d+ failed, \d+ passed' /tmp/failed_logs.txt | tail -1 || echo "")

          # â”€â”€ Extract PowerShell parse errors â”€â”€
          grep -iE "Parse errors in|DuplicateFormalParameter|TermExpected|Missing closing" /tmp/failed_logs.txt \
            > /tmp/ps_errors.txt 2>/dev/null || true
          PS_COUNT=$(wc -l < /tmp/ps_errors.txt | tr -d ' ')

          # â”€â”€ Extract bash syntax errors â”€â”€
          grep -iE "syntax error|bash -n.*failed|^not ok |not ok " /tmp/failed_logs.txt \
            > /tmp/bash_errors.txt 2>/dev/null || true
          BASH_COUNT=$(wc -l < /tmp/bash_errors.txt | tr -d ' ')

          TOTAL=$((PYTEST_COUNT + PS_COUNT + BASH_COUNT))
          echo "total_failures=$TOTAL" >> "$GITHUB_OUTPUT"
          echo "pytest_count=$PYTEST_COUNT" >> "$GITHUB_OUTPUT"
          echo "pytest_summary=$PYTEST_SUMMARY" >> "$GITHUB_OUTPUT"
          echo "ps_count=$PS_COUNT" >> "$GITHUB_OUTPUT"
          echo "bash_count=$BASH_COUNT" >> "$GITHUB_OUTPUT"
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"

          # Extract unique affected domains from failure paths
          DOMAINS=$(cat /tmp/pytest_failures.txt 2>/dev/null \
            | grep -oP '^\S+?(?=/)' \
            | sort -u \
            | head -20 \
            | tr '\n' ',' \
            | sed 's/,$//')
          echo "domains=${DOMAINS:-unknown}" >> "$GITHUB_OUTPUT"

          # Extract unique test FILE paths (for targeted re-run command)
          sed 's/::.*$//' /tmp/pytest_failures.txt \
            | sort -u \
            > /tmp/pytest_failing_files.txt 2>/dev/null || true

          # â”€â”€ Build failure details into a FILE (not a variable) â”€â”€
          # Writing to a file avoids shell expansion issues with backticks
          : > /tmp/failure_details.txt
          if [[ "$PYTEST_COUNT" -gt 0 ]]; then
            printf '```\n' >> /tmp/failure_details.txt
            printf '# pytest failures (%s):\n' "$PYTEST_COUNT" >> /tmp/failure_details.txt
            head -50 /tmp/pytest_failures.txt >> /tmp/failure_details.txt
            if [[ "$PYTEST_COUNT" -gt 50 ]]; then
              printf '... and %d more\n' "$((PYTEST_COUNT - 50))" >> /tmp/failure_details.txt
            fi
            printf '```\n' >> /tmp/failure_details.txt
          fi

          if [[ "$PS_COUNT" -gt 0 ]]; then
            printf '```\n' >> /tmp/failure_details.txt
            printf '# PowerShell errors (%s):\n' "$PS_COUNT" >> /tmp/failure_details.txt
            head -20 /tmp/ps_errors.txt >> /tmp/failure_details.txt
            printf '```\n' >> /tmp/failure_details.txt
          fi

          if [[ "$BASH_COUNT" -gt 0 ]]; then
            printf '```\n' >> /tmp/failure_details.txt
            printf '# Bash errors (%s):\n' "$BASH_COUNT" >> /tmp/failure_details.txt
            head -20 /tmp/bash_errors.txt >> /tmp/failure_details.txt
            printf '```\n' >> /tmp/failure_details.txt
          fi

          echo "Parsed: pytest=$PYTEST_COUNT ps=$PS_COUNT bash=$BASH_COUNT total=$TOTAL"

      # â”€â”€ 2. Dedup guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Check for existing auto-heal issue"
        id: dedup
        if: steps.logs.outputs.total_failures != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OPEN=$(gh issue list \
            --repo "${{ github.repository }}" \
            --label "auto-heal" \
            --state open \
            --json number \
            --jq 'length')
          echo "Open auto-heal issues: $OPEN"
          echo "open_count=$OPEN" >> "$GITHUB_OUTPUT"

      # â”€â”€ 3. Create healing issue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Create fix issue"
        id: create
        if: >-
          steps.logs.outputs.total_failures != '0' &&
          steps.dedup.outputs.open_count == '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RUN_ID="${{ steps.logs.outputs.run_id }}"
          PYTEST_COUNT="${{ steps.logs.outputs.pytest_count }}"
          PYTEST_SUMMARY="${{ steps.logs.outputs.pytest_summary }}"
          PS_COUNT="${{ steps.logs.outputs.ps_count }}"
          BASH_COUNT="${{ steps.logs.outputs.bash_count }}"
          TOTAL="${{ steps.logs.outputs.total_failures }}"
          DOMAINS="${{ steps.logs.outputs.domains }}"

          # Ensure labels exist
          gh label create "auto-heal" \
            --repo "${{ github.repository }}" \
            --description "Auto-generated test failure fix" \
            --color "D93F0B" \
            2>/dev/null || true

          TITLE="[AUTO-HEAL] Fix $TOTAL test failure(s) in ${DOMAINS} from CI run #${RUN_ID}"

          # â”€â”€ Build the issue body in a FILE to avoid shell expansion â”€â”€
          # (backticks in failure details were causing command substitution)
          cat > /tmp/issue_body.md <<'STATIC_EOF'
          ## Task: Fix test failures detected in CI

          ### Context

          STATIC_EOF

          # Append dynamic content with proper escaping
          {
            printf 'The CI pipeline on `main` has **%s failure(s)** (%s).\n' "$TOTAL" "${PYTEST_SUMMARY:-details below}"
            printf 'These must be fixed to keep the project healthy.\n\n'
            printf '**CI Run:** https://github.com/%s/actions/runs/%s\n\n' "${{ github.repository }}" "$RUN_ID"
            printf '| Framework | Failures |\n'
            printf '|-----------|----------|\n'
            printf '| pytest | %s |\n' "$PYTEST_COUNT"
            printf '| PowerShell | %s |\n' "$PS_COUNT"
            printf '| Bash/bats | %s |\n\n' "$BASH_COUNT"
            printf '### Failure Details\n\n'
          } >> /tmp/issue_body.md

          # Append failure details from file (safe â€” no shell expansion)
          cat /tmp/failure_details.txt >> /tmp/issue_body.md

          # â”€â”€ Build targeted test command â”€â”€
          FAILING_FILES=""
          if [[ -s /tmp/pytest_failing_files.txt ]]; then
            FAILING_FILES=$(cat /tmp/pytest_failing_files.txt | tr '\n' ' ')
          fi

          cat >> /tmp/issue_body.md <<'INSTRUCTIONS_EOF'

          ### How to Fix

          1. **Reproduce locally** â€” run ONLY the failing tests (not the full suite):
          INSTRUCTIONS_EOF

          # Add the targeted pytest command
          {
            printf '   ```bash\n'
            if [[ -n "$FAILING_FILES" ]]; then
              printf '   python -m pytest --tb=short -q \\\n'
              # List each failing test file, one per line for readability
              while IFS= read -r f; do
                printf '     %s \\\n' "$f"
              done < /tmp/pytest_failing_files.txt
              printf '     2>&1 | tail -60\n'
            else
              printf '   python -m pytest --tb=short -q 2>&1 | tail -60\n'
            fi
            printf '   ```\n'
          } >> /tmp/issue_body.md

          cat >> /tmp/issue_body.md <<'TAIL_EOF'

             > **Important:** Only run the tests listed above. Do NOT re-run the full test suite â€” 7000+ other tests already pass.

          2. **Common root causes** for generated scripts:
             - **Fixture mismatch**: Test expects keys that don't exist in `tests/fixtures/*.json` â€” update the fixture
             - **URL pattern wrong**: Mock URL doesn't match what the script builds â€” check `responses.add()` URL vs script URL
             - **Import errors**: Missing `__init__.py` or wrong relative import â€” check the domain's package structure
             - **Unescaped characters**: Apostrophes or quotes in YAML synopsis/description â€” fix the YAML in `_generator/definitions/` and regenerate
             - **PowerShell duplicate params**: Already fixed in template â€” regenerate with `python -m _generator.generate -d <yaml>`
          3. **Fix the root cause** (template, YAML definition, or fixture) â€” not just the symptom
          4. **Regenerate if needed**: `python -m _generator.generate -d _generator/definitions/<name>.yaml`
          5. **Verify locally** before committing â€” run ONLY the affected tests:
             ```bash
             python -m pytest -q --tb=line <failing_test_files> 2>&1 | tail -10
             ```

          ### Acceptance Criteria

          - [ ] All previously-failing tests now pass (run the targeted command above)
          - [ ] No tests were deleted or skipped to hide failures
          - [ ] Any template/YAML fixes are applied so future regeneration is clean

          ### Reference
          See `.github/copilot-instructions.md` for project conventions.
          TAIL_EOF

          # Dedent the body (heredoc indentation artifact)
          sed -i 's/^          //' /tmp/issue_body.md

          ISSUE_URL=$(gh issue create \
            --repo "${{ github.repository }}" \
            --title "$TITLE" \
            --body-file /tmp/issue_body.md \
            --label "auto-heal" \
            --label "bug")

          echo "Created: $ISSUE_URL"
          ISSUE_NUM=$(echo "$ISSUE_URL" | grep -oP '\d+$')
          echo "issue_number=$ISSUE_NUM" >> "$GITHUB_OUTPUT"
          echo "issue_url=$ISSUE_URL" >> "$GITHUB_OUTPUT"

      # â”€â”€ 4. Assign copilot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Assign Copilot to fix issue"
        if: steps.create.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.create.outputs.issue_number }}"
          echo "Assigning copilot to issue #$ISSUE_NUM..."

          HTTP_CODE=$(curl -s -o /tmp/assign_resp.json -w "%{http_code}" \
            -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$ISSUE_NUM/assignees" \
            -d '{"assignees":["copilot"]}')

          if [[ "$HTTP_CODE" -lt 300 ]]; then
            echo "âœ… Assigned copilot to issue #$ISSUE_NUM"
          else
            echo "âš ï¸  Assignment returned HTTP $HTTP_CODE"
            cat /tmp/assign_resp.json 2>/dev/null | head -5
            echo ""
            echo "Issue was created successfully â€” assign copilot manually:"
            echo "  ${{ steps.create.outputs.issue_url }}"
          fi

      # â”€â”€ 5. Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Summary"
        if: always()
        run: |
          echo "### Auto-Heal Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          TOTAL="${{ steps.logs.outputs.total_failures }}"
          if [[ "$TOTAL" == "0" ]]; then
            echo "No test failures detected (workflow may have failed for other reasons)." >> "$GITHUB_STEP_SUMMARY"
          elif [[ "${{ steps.dedup.outputs.open_count }}" != "0" ]]; then
            echo "â¸ï¸ **Skipped** â€” an auto-heal issue is already open." >> "$GITHUB_STEP_SUMMARY"
          elif [[ -n "${{ steps.create.outputs.issue_url }}" ]]; then
            echo "ðŸ©¹ **Created fix issue:** ${{ steps.create.outputs.issue_url }}" >> "$GITHUB_STEP_SUMMARY"
            echo "**Failures:** $TOTAL (pytest: ${{ steps.logs.outputs.pytest_count }}, PS: ${{ steps.logs.outputs.ps_count }}, bash: ${{ steps.logs.outputs.bash_count }})" >> "$GITHUB_STEP_SUMMARY"
          fi
