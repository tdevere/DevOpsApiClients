# =============================================================================
# Project Completion â€” Scheduled Copilot Agent Automation
#
# Runs every 6 hours (or on-demand). Each run:
#   1. Assesses the project against a completion checklist
#   2. Identifies the single highest-priority remaining task
#   3. Creates a focused GitHub Issue assigned to Copilot Coding Agent
#   4. Copilot picks up the issue, does the work, opens a PR
#
# On the next scheduled run, the tracker re-evaluates and picks the next task.
# Once all checks pass, the workflow emits a "project complete" summary and stops.
#
# Guard rails:
#   - Skips if there's already an open 'auto-completion' issue (prevents pileup)
#   - Hard cap of 200 total auto-completion issues (safety brake)
#   - Each issue is scoped to one well-defined task with acceptance criteria
# =============================================================================
name: Project Completion

on:
  schedule:
    - cron: '0 */6 * * *'     # Every 6 hours
  workflow_dispatch:
    inputs:
      force:
        description: 'Create task even if one is already open'
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  contents: read
  issues: write

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
jobs:

  # ---------------------------------------------------------------------------
  # 1. Assess â€” Run the completion tracker to find the next task
  # ---------------------------------------------------------------------------
  assess:
    name: "Assess Completion"
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.tracker.outputs.status }}
      has_task: ${{ steps.tracker.outputs.has_task }}
      task_title: ${{ steps.tracker.outputs.task_title }}
      task_body: ${{ steps.tracker.outputs.task_body }}
      task_labels: ${{ steps.tracker.outputs.task_labels }}
      should_skip: ${{ steps.guard.outputs.should_skip }}
    steps:
      - uses: actions/checkout@v4

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: "Install dependencies"
        run: pip install requests responses pytest pyyaml

      # â”€â”€ Guard: check for existing open auto-completion issues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Check for open tasks"
        id: guard
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FORCE="${{ github.event.inputs.force || 'false' }}"

          # Count open auto-completion issues
          OPEN=$(gh issue list \
            --repo "${{ github.repository }}" \
            --label "auto-completion" \
            --state open \
            --json number \
            --jq 'length')
          echo "Open auto-completion issues: $OPEN"

          # Count total auto-completion issues ever created (safety cap)
          TOTAL=$(gh issue list \
            --repo "${{ github.repository }}" \
            --label "auto-completion" \
            --state all \
            --limit 250 \
            --json number \
            --jq 'length')
          echo "Total auto-completion issues: $TOTAL"

          if [[ "$FORCE" == "true" ]]; then
            echo "Force mode â€” skipping guards"
            echo "should_skip=false" >> "$GITHUB_OUTPUT"
          elif [[ "$OPEN" -gt "0" ]]; then
            echo "â¸ï¸  Skipping â€” $OPEN auto-completion issue(s) still open"
            echo "should_skip=true" >> "$GITHUB_OUTPUT"
          elif [[ "$TOTAL" -ge "200" ]]; then
            echo "ðŸ›‘ Safety cap reached â€” 200 auto-completion issues created"
            echo "should_skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_skip=false" >> "$GITHUB_OUTPUT"
          fi

      # â”€â”€ Run the completion tracker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Run completion tracker"
        id: tracker
        if: steps.guard.outputs.should_skip != 'true'
        run: |
          # Run verbose for CI logs
          python _generator/completion_tracker.py --verbose 2>&1 || true
          echo ""

          # Run clean for JSON parsing
          python3 << 'PYEOF'
          import subprocess, sys, os, json, uuid

          r = subprocess.run(
              [sys.executable, "_generator/completion_tracker.py"],
              capture_output=True, text=True,
          )
          # Exit codes: 0 = complete, 1 = incomplete/blocked
          if r.returncode not in (0, 1):
              print(f"Tracker error (rc={r.returncode}): {r.stderr}")
              sys.exit(1)

          data = json.loads(r.stdout)
          status = data["status"]
          out = os.environ.get("GITHUB_OUTPUT", "")
          if not out:
              print(json.dumps(data, indent=2))
              sys.exit(0)

          with open(out, "a") as f:
              f.write(f"status={status}\n")

              if status == "blocked":
                  reason = data.get("reason", "Blocked by open auto-heal issue")
                  f.write("has_task=false\n")
                  f.write(f"blocked_reason={reason}\n")
                  print(f"â¸ï¸  {reason}")

              elif status == "incomplete":
                  task = data.get("next_task", {})
                  title = task.get("title", "Unknown task")
                  body = task.get("body", "No details.")
                  labels = ",".join(task.get("labels", ["auto-completion"]))
                  f.write("has_task=true\n")
                  f.write(f"task_title={title}\n")
                  delim = f"ghadelimiter_{uuid.uuid4().hex[:8]}"
                  f.write(f"task_body<<{delim}\n{body}\n{delim}\n")
                  f.write(f"task_labels={labels}\n")
                  print(f"ðŸ“‹ Next task: {title}")

              else:  # complete
                  f.write("has_task=false\n")
                  print("ðŸŽ‰ All checks passed â€” project is complete!")
          PYEOF

      # â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: "Summary"
        if: always()
        run: |
          echo "### Project Completion Status" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [[ "${{ steps.guard.outputs.should_skip }}" == "true" ]]; then
            echo "â¸ï¸ **Skipped** â€” previous task still in progress or safety cap reached." >> "$GITHUB_STEP_SUMMARY"
          elif [[ "${{ steps.tracker.outputs.status }}" == "blocked" ]]; then
            echo "â¸ï¸ **Blocked** â€” ${{ steps.tracker.outputs.blocked_reason }}" >> "$GITHUB_STEP_SUMMARY"
          elif [[ "${{ steps.tracker.outputs.status }}" == "complete" ]]; then
            echo "ðŸŽ‰ **All checks passed** â€” project is complete!" >> "$GITHUB_STEP_SUMMARY"
          elif [[ "${{ steps.tracker.outputs.has_task }}" == "true" ]]; then
            echo "ðŸ“‹ **Next task:** ${{ steps.tracker.outputs.task_title }}" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âš ï¸ Tracker did not produce a result." >> "$GITHUB_STEP_SUMMARY"
          fi

  # ---------------------------------------------------------------------------
  # 2. Dispatch â€” Create a GitHub Issue and assign to Copilot
  # ---------------------------------------------------------------------------
  dispatch:
    name: "Dispatch to Copilot"
    runs-on: ubuntu-latest
    needs: assess
    if: |
      needs.assess.outputs.should_skip != 'true' &&
      needs.assess.outputs.has_task == 'true'
    steps:
      - name: "Ensure auto-completion label exists"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh label create "auto-completion" \
            --repo "${{ github.repository }}" \
            --description "Auto-generated project completion task" \
            --color "0E8A16" \
            2>/dev/null || true

      - name: "Create issue"
        id: create_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TASK_TITLE: ${{ needs.assess.outputs.task_title }}
          TASK_BODY: ${{ needs.assess.outputs.task_body }}
          TASK_LABELS: ${{ needs.assess.outputs.task_labels }}
        run: |
          echo "Creating issue: $TASK_TITLE"

          # Parse comma-separated labels into --label flags
          LABEL_FLAGS=""
          IFS=',' read -ra LABELS <<< "$TASK_LABELS"
          for label in "${LABELS[@]}"; do
            label=$(echo "$label" | xargs)  # trim whitespace
            if [[ -n "$label" ]]; then
              # Ensure the label exists
              gh label create "$label" \
                --repo "${{ github.repository }}" \
                --color "EDEDED" \
                2>/dev/null || true
              LABEL_FLAGS="$LABEL_FLAGS --label $label"
            fi
          done

          # Create the issue (without assignee â€” added separately)
          ISSUE_URL=$(gh issue create \
            --repo "${{ github.repository }}" \
            --title "$TASK_TITLE" \
            --body "$TASK_BODY" \
            $LABEL_FLAGS)

          echo "âœ… Created: $ISSUE_URL"
          ISSUE_NUM=$(echo "$ISSUE_URL" | grep -oP '\d+$')
          echo "issue_number=$ISSUE_NUM" >> "$GITHUB_OUTPUT"
          echo "issue_url=$ISSUE_URL" >> "$GITHUB_OUTPUT"

      - name: "Assign Copilot to issue"
        if: steps.create_issue.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.create_issue.outputs.issue_number }}"
          REPO="${{ github.repository }}"
          echo "Assigning copilot to issue #$ISSUE_NUM..."

          # Use the REST API directly â€” gh CLI doesn't recognize bot assignees
          HTTP_CODE=$(curl -s -o /tmp/assign_resp.json -w "%{http_code}" \
            -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$REPO/issues/$ISSUE_NUM/assignees" \
            -d '{"assignees":["copilot"]}')

          if [[ "$HTTP_CODE" -lt 300 ]]; then
            echo "âœ… Assigned copilot to issue #$ISSUE_NUM"
          else
            echo "âš ï¸  Could not assign copilot (HTTP $HTTP_CODE)."
            cat /tmp/assign_resp.json 2>/dev/null | head -5
            echo ""
            echo "The issue was created successfully. Assign copilot manually:"
            echo "  ${{ steps.create_issue.outputs.issue_url }}"
          fi

      - name: "Summary"
        if: always() && steps.create_issue.outputs.issue_url != ''
        run: |
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "### Dispatched Task" >> "$GITHUB_STEP_SUMMARY"
          echo "**Issue:** ${{ steps.create_issue.outputs.issue_url }}" >> "$GITHUB_STEP_SUMMARY"
          echo "**Title:** ${{ needs.assess.outputs.task_title }}" >> "$GITHUB_STEP_SUMMARY"
